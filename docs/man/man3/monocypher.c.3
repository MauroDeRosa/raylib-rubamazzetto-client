.TH "include/external/external/monocypher.c" 3 "Sun May 8 2022" "Ruba Mazzetto" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/external/external/monocypher.c
.SH SYNOPSIS
.br
.PP
\fC#include 'monocypher\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBblock\fP"
.br
.RI "Argon2 i ///\&. "
.ti -1c
.RI "struct \fBgidx_ctx\fP"
.br
.ti -1c
.RI "struct \fBge\fP"
.br
.RI "Ed25519 ///\&. "
.ti -1c
.RI "struct \fBge_cached\fP"
.br
.ti -1c
.RI "struct \fBge_precomp\fP"
.br
.ti -1c
.RI "struct \fBslide_ctx\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBFOR_T\fP(type,  i,  start,  end)   for (type i = (start); i < (end); i++)"
.br
.RI "Utilities ///\&. "
.ti -1c
.RI "#define \fBFOR\fP(i,  start,  end)   \fBFOR_T\fP(size_t, i, start, end)"
.br
.ti -1c
.RI "#define \fBCOPY\fP(\fBdst\fP,  src,  size)   \fBFOR\fP(i, 0, size) (\fBdst\fP)[i] = (src)[i]"
.br
.ti -1c
.RI "#define \fBZERO\fP(buf,  size)   \fBFOR\fP(i, 0, size) (buf)[i] = 0"
.br
.ti -1c
.RI "#define \fBWIPE_CTX\fP(ctx)   \fBcrypto_wipe\fP(ctx   , sizeof(*(ctx)))"
.br
.ti -1c
.RI "#define \fBWIPE_BUFFER\fP(buffer)   \fBcrypto_wipe\fP(buffer, sizeof(buffer))"
.br
.ti -1c
.RI "#define \fBMIN\fP(a,  b)   ((a) <= (b) ? (a) : (b))"
.br
.ti -1c
.RI "#define \fBMAX\fP(a,  b)   ((a) >= (b) ? (a) : (b))"
.br
.ti -1c
.RI "#define \fBQUARTERROUND\fP(a,  b,  c,  d)"
.br
.RI "Chacha 20 ///\&. "
.ti -1c
.RI "#define \fBBLAKE2_G\fP(a,  b,  c,  d,  x,  y)"
.br
.ti -1c
.RI "#define \fBBLAKE2_ROUND\fP(i)"
.br
.ti -1c
.RI "#define \fBLSB\fP(x)   ((x) & 0xffffffff)"
.br
.ti -1c
.RI "#define \fBG\fP(a,  b,  c,  d)"
.br
.ti -1c
.RI "#define \fBROUND\fP(v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15)"
.br
.ti -1c
.RI "#define \fBFE_CARRY\fP"
.br
.ti -1c
.RI "#define \fBP_W_WIDTH\fP   3"
.br
.ti -1c
.RI "#define \fBB_W_WIDTH\fP   5"
.br
.ti -1c
.RI "#define \fBP_W_SIZE\fP   (1<<(\fBP_W_WIDTH\fP\-2))"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int8_t \fBi8\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBu8\fP"
.br
.ti -1c
.RI "typedef int16_t \fBi16\fP"
.br
.ti -1c
.RI "typedef uint32_t \fBu32\fP"
.br
.ti -1c
.RI "typedef int32_t \fBi32\fP"
.br
.ti -1c
.RI "typedef int64_t \fBi64\fP"
.br
.ti -1c
.RI "typedef uint64_t \fBu64\fP"
.br
.ti -1c
.RI "typedef \fBi32\fP \fBfe\fP[10]"
.br
.RI "Arithmetic modulo 2^255 - 19 ///\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBcrypto_verify16\fP (const \fBu8\fP a[16], const \fBu8\fP b[16])"
.br
.RI "High level interface ///\&. "
.ti -1c
.RI "int \fBcrypto_verify32\fP (const \fBu8\fP a[32], const \fBu8\fP b[32])"
.br
.ti -1c
.RI "int \fBcrypto_verify64\fP (const \fBu8\fP a[64], const \fBu8\fP b[64])"
.br
.ti -1c
.RI "void \fBcrypto_wipe\fP (void *secret, size_t size)"
.br
.ti -1c
.RI "void \fBcrypto_hchacha20\fP (\fBu8\fP out[32], const \fBu8\fP key[32], const \fBu8\fP in[16])"
.br
.RI "Low level primitives ///\&. "
.ti -1c
.RI "\fBu64\fP \fBcrypto_chacha20_ctr\fP (\fBu8\fP *cipher_text, const \fBu8\fP *plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[8], \fBu64\fP ctr)"
.br
.ti -1c
.RI "\fBu32\fP \fBcrypto_ietf_chacha20_ctr\fP (\fBu8\fP *cipher_text, const \fBu8\fP *plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[12], \fBu32\fP ctr)"
.br
.ti -1c
.RI "\fBu64\fP \fBcrypto_xchacha20_ctr\fP (\fBu8\fP *cipher_text, const \fBu8\fP *plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[24], \fBu64\fP ctr)"
.br
.ti -1c
.RI "void \fBcrypto_chacha20\fP (\fBu8\fP *cipher_text, const \fBu8\fP *plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[8])"
.br
.ti -1c
.RI "void \fBcrypto_ietf_chacha20\fP (\fBu8\fP *cipher_text, const \fBu8\fP *plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[12])"
.br
.ti -1c
.RI "void \fBcrypto_xchacha20\fP (\fBu8\fP *cipher_text, const \fBu8\fP *plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[24])"
.br
.ti -1c
.RI "void \fBcrypto_poly1305_init\fP (\fBcrypto_poly1305_ctx\fP *ctx, const \fBu8\fP key[32])"
.br
.ti -1c
.RI "void \fBcrypto_poly1305_update\fP (\fBcrypto_poly1305_ctx\fP *ctx, const \fBu8\fP *message, size_t message_size)"
.br
.ti -1c
.RI "void \fBcrypto_poly1305_final\fP (\fBcrypto_poly1305_ctx\fP *ctx, \fBu8\fP mac[16])"
.br
.ti -1c
.RI "void \fBcrypto_poly1305\fP (\fBu8\fP mac[16], const \fBu8\fP *message, size_t message_size, const \fBu8\fP key[32])"
.br
.ti -1c
.RI "void \fBcrypto_blake2b_general_init\fP (\fBcrypto_blake2b_ctx\fP *ctx, size_t hash_size, const \fBu8\fP *key, size_t key_size)"
.br
.ti -1c
.RI "void \fBcrypto_blake2b_init\fP (\fBcrypto_blake2b_ctx\fP *ctx)"
.br
.ti -1c
.RI "void \fBcrypto_blake2b_update\fP (\fBcrypto_blake2b_ctx\fP *ctx, const \fBu8\fP *message, size_t message_size)"
.br
.ti -1c
.RI "void \fBcrypto_blake2b_final\fP (\fBcrypto_blake2b_ctx\fP *ctx, \fBu8\fP *hash)"
.br
.ti -1c
.RI "void \fBcrypto_blake2b_general\fP (\fBu8\fP *hash, size_t hash_size, const \fBu8\fP *key, size_t key_size, const \fBu8\fP *message, size_t message_size)"
.br
.ti -1c
.RI "void \fBcrypto_blake2b\fP (\fBu8\fP hash[64], const \fBu8\fP *message, size_t message_size)"
.br
.ti -1c
.RI "void \fBcrypto_argon2i_general\fP (\fBu8\fP *hash, \fBu32\fP hash_size, void *work_area, \fBu32\fP nb_blocks, \fBu32\fP nb_iterations, const \fBu8\fP *password, \fBu32\fP password_size, const \fBu8\fP *salt, \fBu32\fP salt_size, const \fBu8\fP *key, \fBu32\fP key_size, const \fBu8\fP *ad, \fBu32\fP ad_size)"
.br
.ti -1c
.RI "void \fBcrypto_argon2i\fP (\fBu8\fP *hash, \fBu32\fP hash_size, void *work_area, \fBu32\fP nb_blocks, \fBu32\fP nb_iterations, const \fBu8\fP *password, \fBu32\fP password_size, const \fBu8\fP *salt, \fBu32\fP salt_size)"
.br
.ti -1c
.RI "void \fBcrypto_x25519\fP (\fBu8\fP raw_shared_secret[32], const \fBu8\fP your_secret_key[32], const \fBu8\fP their_public_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_x25519_public_key\fP (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_sign_public_key_custom_hash\fP (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32], const \fBcrypto_sign_vtable\fP *hash)"
.br
.ti -1c
.RI "void \fBcrypto_sign_public_key\fP (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_sign_init_first_pass_custom_hash\fP (\fBcrypto_sign_ctx_abstract\fP *ctx, const \fBu8\fP secret_key[32], const \fBu8\fP public_key[32], const \fBcrypto_sign_vtable\fP *hash)"
.br
.ti -1c
.RI "void \fBcrypto_sign_init_first_pass\fP (\fBcrypto_sign_ctx_abstract\fP *ctx, const \fBu8\fP secret_key[32], const \fBu8\fP public_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_sign_update\fP (\fBcrypto_sign_ctx_abstract\fP *ctx, const \fBu8\fP *msg, size_t msg_size)"
.br
.ti -1c
.RI "void \fBcrypto_sign_init_second_pass\fP (\fBcrypto_sign_ctx_abstract\fP *ctx)"
.br
.ti -1c
.RI "void \fBcrypto_sign_final\fP (\fBcrypto_sign_ctx_abstract\fP *ctx, \fBu8\fP signature[64])"
.br
.ti -1c
.RI "void \fBcrypto_sign\fP (\fBu8\fP signature[64], const \fBu8\fP secret_key[32], const \fBu8\fP public_key[32], const \fBu8\fP *message, size_t message_size)"
.br
.ti -1c
.RI "void \fBcrypto_check_init_custom_hash\fP (\fBcrypto_check_ctx_abstract\fP *ctx, const \fBu8\fP signature[64], const \fBu8\fP public_key[32], const \fBcrypto_sign_vtable\fP *hash)"
.br
.ti -1c
.RI "void \fBcrypto_check_init\fP (\fBcrypto_check_ctx_abstract\fP *ctx, const \fBu8\fP signature[64], const \fBu8\fP public_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_check_update\fP (\fBcrypto_check_ctx_abstract\fP *ctx, const \fBu8\fP *msg, size_t msg_size)"
.br
.ti -1c
.RI "int \fBcrypto_check_final\fP (\fBcrypto_check_ctx_abstract\fP *ctx)"
.br
.ti -1c
.RI "int \fBcrypto_check\fP (const \fBu8\fP signature[64], const \fBu8\fP public_key[32], const \fBu8\fP *message, size_t message_size)"
.br
.ti -1c
.RI "void \fBcrypto_from_eddsa_private\fP (\fBu8\fP x25519[32], const \fBu8\fP eddsa[32])"
.br
.RI "EdDSA to X25519 ///\&. "
.ti -1c
.RI "void \fBcrypto_from_eddsa_public\fP (\fBu8\fP x25519[32], const \fBu8\fP eddsa[32])"
.br
.ti -1c
.RI "void \fBcrypto_x25519_dirty_small\fP (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_x25519_dirty_fast\fP (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"
.br
.ti -1c
.RI "void \fBcrypto_hidden_to_curve\fP (uint8_t curve[32], const uint8_t hidden[32])"
.br
.ti -1c
.RI "int \fBcrypto_curve_to_hidden\fP (\fBu8\fP hidden[32], const \fBu8\fP public_key[32], \fBu8\fP tweak)"
.br
.ti -1c
.RI "void \fBcrypto_hidden_key_pair\fP (\fBu8\fP hidden[32], \fBu8\fP secret_key[32], \fBu8\fP seed[32])"
.br
.ti -1c
.RI "void \fBcrypto_key_exchange\fP (\fBu8\fP shared_key[32], const \fBu8\fP your_secret_key[32], const \fBu8\fP their_public_key[32])"
.br
.RI "Key exchange ///\&. "
.ti -1c
.RI "void \fBcrypto_x25519_inverse\fP (\fBu8\fP blind_salt[32], const \fBu8\fP private_key[32], const \fBu8\fP curve_point[32])"
.br
.ti -1c
.RI "void \fBcrypto_lock_aead\fP (\fBu8\fP mac[16], \fBu8\fP *cipher_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP *ad, size_t ad_size, const \fBu8\fP *plain_text, size_t text_size)"
.br
.ti -1c
.RI "int \fBcrypto_unlock_aead\fP (\fBu8\fP *plain_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP mac[16], const \fBu8\fP *ad, size_t ad_size, const \fBu8\fP *cipher_text, size_t text_size)"
.br
.ti -1c
.RI "void \fBcrypto_lock\fP (\fBu8\fP mac[16], \fBu8\fP *cipher_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP *plain_text, size_t text_size)"
.br
.ti -1c
.RI "int \fBcrypto_unlock\fP (\fBu8\fP *plain_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP mac[16], const \fBu8\fP *cipher_text, size_t text_size)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBcrypto_sign_vtable\fP \fBcrypto_blake2b_vtable\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define B_W_WIDTH   5"

.SS "#define BLAKE2_G(a, b, c, d, x, y)"
\fBValue:\fP
.PP
.nf
    a += b + x;  d = rotr64(d ^ a, 32); \
    c += d;      b = rotr64(b ^ c, 24); \
    a += b + y;  d = rotr64(d ^ a, 16); \
    c += d;      b = rotr64(b ^ c, 63)
.fi
.SS "#define BLAKE2_ROUND(i)"
\fBValue:\fP
.PP
.nf
    BLAKE2_G(v0, v4, v8 , v12, input[sigma[i][ 0]], input[sigma[i][ 1]]); \
    BLAKE2_G(v1, v5, v9 , v13, input[sigma[i][ 2]], input[sigma[i][ 3]]); \
    BLAKE2_G(v2, v6, v10, v14, input[sigma[i][ 4]], input[sigma[i][ 5]]); \
    BLAKE2_G(v3, v7, v11, v15, input[sigma[i][ 6]], input[sigma[i][ 7]]); \
    BLAKE2_G(v0, v5, v10, v15, input[sigma[i][ 8]], input[sigma[i][ 9]]); \
    BLAKE2_G(v1, v6, v11, v12, input[sigma[i][10]], input[sigma[i][11]]); \
    BLAKE2_G(v2, v7, v8 , v13, input[sigma[i][12]], input[sigma[i][13]]); \
    BLAKE2_G(v3, v4, v9 , v14, input[sigma[i][14]], input[sigma[i][15]])
.fi
.SS "#define COPY(\fBdst\fP, src, size)   \fBFOR\fP(i, 0, size) (\fBdst\fP)[i] = (src)[i]"

.SS "#define FE_CARRY"
\fBValue:\fP
.PP
.nf
    i64 c;                                                              \
    c = (t0 + ((i64)1<<25)) >> 26;  t0 -= c * ((i64)1 << 26);  t1 += c; \
    c = (t4 + ((i64)1<<25)) >> 26;  t4 -= c * ((i64)1 << 26);  t5 += c; \
    c = (t1 + ((i64)1<<24)) >> 25;  t1 -= c * ((i64)1 << 25);  t2 += c; \
    c = (t5 + ((i64)1<<24)) >> 25;  t5 -= c * ((i64)1 << 25);  t6 += c; \
    c = (t2 + ((i64)1<<25)) >> 26;  t2 -= c * ((i64)1 << 26);  t3 += c; \
    c = (t6 + ((i64)1<<25)) >> 26;  t6 -= c * ((i64)1 << 26);  t7 += c; \
    c = (t3 + ((i64)1<<24)) >> 25;  t3 -= c * ((i64)1 << 25);  t4 += c; \
    c = (t7 + ((i64)1<<24)) >> 25;  t7 -= c * ((i64)1 << 25);  t8 += c; \
    c = (t4 + ((i64)1<<25)) >> 26;  t4 -= c * ((i64)1 << 26);  t5 += c; \
    c = (t8 + ((i64)1<<25)) >> 26;  t8 -= c * ((i64)1 << 26);  t9 += c; \
    c = (t9 + ((i64)1<<24)) >> 25;  t9 -= c * ((i64)1 << 25);  t0 += c * 19; \
    c = (t0 + ((i64)1<<25)) >> 26;  t0 -= c * ((i64)1 << 26);  t1 += c; \
    h[0]=(i32)t0;  h[1]=(i32)t1;  h[2]=(i32)t2;  h[3]=(i32)t3;  h[4]=(i32)t4; \
    h[5]=(i32)t5;  h[6]=(i32)t6;  h[7]=(i32)t7;  h[8]=(i32)t8;  h[9]=(i32)t9
.fi
.SS "#define FOR(i, start, end)   \fBFOR_T\fP(size_t, i, start, end)"

.SS "#define FOR_T(type, i, start, end)   for (type i = (start); i < (end); i++)"

.PP
Utilities ///\&. 
.SS "#define G(a, b, c, d)"
\fBValue:\fP
.PP
.nf
    a += b + 2 * LSB(a) * LSB(b);  d ^= a;  d = rotr64(d, 32);   \
    c += d + 2 * LSB(c) * LSB(d);  b ^= c;  b = rotr64(b, 24);   \
    a += b + 2 * LSB(a) * LSB(b);  d ^= a;  d = rotr64(d, 16);   \
    c += d + 2 * LSB(c) * LSB(d);  b ^= c;  b = rotr64(b, 63)
.fi
.SS "#define LSB(x)   ((x) & 0xffffffff)"

.SS "#define MAX(a, b)   ((a) >= (b) ? (a) : (b))"

.SS "#define MIN(a, b)   ((a) <= (b) ? (a) : (b))"

.SS "#define P_W_SIZE   (1<<(\fBP_W_WIDTH\fP\-2))"

.SS "#define P_W_WIDTH   3"

.SS "#define QUARTERROUND(a, b, c, d)"
\fBValue:\fP
.PP
.nf
    a += b;  d = rotl32(d ^ a, 16);  \
    c += d;  b = rotl32(b ^ c, 12);  \
    a += b;  d = rotl32(d ^ a,  8);  \
    c += d;  b = rotl32(b ^ c,  7)
.fi
.PP
Chacha 20 ///\&. 
.SS "#define ROUND(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)"
\fBValue:\fP
.PP
.nf
    G(v0, v4,  v8, v12);  G(v1, v5,  v9, v13);          \
    G(v2, v6, v10, v14);  G(v3, v7, v11, v15);          \
    G(v0, v5, v10, v15);  G(v1, v6, v11, v12);          \
    G(v2, v7,  v8, v13);  G(v3, v4,  v9, v14)
.fi
.SS "#define WIPE_BUFFER(buffer)   \fBcrypto_wipe\fP(buffer, sizeof(buffer))"

.SS "#define WIPE_CTX(ctx)   \fBcrypto_wipe\fP(ctx   , sizeof(*(ctx)))"

.SS "#define ZERO(buf, size)   \fBFOR\fP(i, 0, size) (buf)[i] = 0"

.SH "Typedef Documentation"
.PP 
.SS "typedef \fBi32\fP fe[10]"

.PP
Arithmetic modulo 2^255 - 19 ///\&. 
.SS "typedef int16_t \fBi16\fP"

.SS "typedef int32_t \fBi32\fP"

.SS "typedef int64_t \fBi64\fP"

.SS "typedef int8_t \fBi8\fP"

.SS "typedef uint32_t \fBu32\fP"

.SS "typedef uint64_t \fBu64\fP"

.SS "typedef uint8_t \fBu8\fP"

.SH "Function Documentation"
.PP 
.SS "void crypto_argon2i (\fBu8\fP * hash, \fBu32\fP hash_size, void * work_area, \fBu32\fP nb_blocks, \fBu32\fP nb_iterations, const \fBu8\fP * password, \fBu32\fP password_size, const \fBu8\fP * salt, \fBu32\fP salt_size)"

.SS "void crypto_argon2i_general (\fBu8\fP * hash, \fBu32\fP hash_size, void * work_area, \fBu32\fP nb_blocks, \fBu32\fP nb_iterations, const \fBu8\fP * password, \fBu32\fP password_size, const \fBu8\fP * salt, \fBu32\fP salt_size, const \fBu8\fP * key, \fBu32\fP key_size, const \fBu8\fP * ad, \fBu32\fP ad_size)"

.SS "void crypto_blake2b (\fBu8\fP hash[64], const \fBu8\fP * message, size_t message_size)"

.SS "void crypto_blake2b_final (\fBcrypto_blake2b_ctx\fP * ctx, \fBu8\fP * hash)"

.SS "void crypto_blake2b_general (\fBu8\fP * hash, size_t hash_size, const \fBu8\fP * key, size_t key_size, const \fBu8\fP * message, size_t message_size)"

.SS "void crypto_blake2b_general_init (\fBcrypto_blake2b_ctx\fP * ctx, size_t hash_size, const \fBu8\fP * key, size_t key_size)"

.SS "void crypto_blake2b_init (\fBcrypto_blake2b_ctx\fP * ctx)"

.SS "void crypto_blake2b_update (\fBcrypto_blake2b_ctx\fP * ctx, const \fBu8\fP * message, size_t message_size)"

.SS "void crypto_chacha20 (\fBu8\fP * cipher_text, const \fBu8\fP * plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[8])"

.SS "\fBu64\fP crypto_chacha20_ctr (\fBu8\fP * cipher_text, const \fBu8\fP * plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[8], \fBu64\fP ctr)"

.SS "int crypto_check (const \fBu8\fP signature[64], const \fBu8\fP public_key[32], const \fBu8\fP * message, size_t message_size)"

.SS "int crypto_check_final (\fBcrypto_check_ctx_abstract\fP * ctx)"

.SS "void crypto_check_init (\fBcrypto_check_ctx_abstract\fP * ctx, const \fBu8\fP signature[64], const \fBu8\fP public_key[32])"

.SS "void crypto_check_init_custom_hash (\fBcrypto_check_ctx_abstract\fP * ctx, const \fBu8\fP signature[64], const \fBu8\fP public_key[32], const \fBcrypto_sign_vtable\fP * hash)"

.SS "void crypto_check_update (\fBcrypto_check_ctx_abstract\fP * ctx, const \fBu8\fP * msg, size_t msg_size)"

.SS "int crypto_curve_to_hidden (\fBu8\fP hidden[32], const \fBu8\fP public_key[32], \fBu8\fP tweak)"

.SS "void crypto_from_eddsa_private (\fBu8\fP x25519[32], const \fBu8\fP eddsa[32])"

.PP
EdDSA to X25519 ///\&. 
.SS "void crypto_from_eddsa_public (\fBu8\fP x25519[32], const \fBu8\fP eddsa[32])"

.SS "void crypto_hchacha20 (\fBu8\fP out[32], const \fBu8\fP key[32], const \fBu8\fP in[16])"

.PP
Low level primitives ///\&. 
.SS "void crypto_hidden_key_pair (\fBu8\fP hidden[32], \fBu8\fP secret_key[32], \fBu8\fP seed[32])"

.SS "void crypto_hidden_to_curve (uint8_t curve[32], const uint8_t hidden[32])"

.SS "void crypto_ietf_chacha20 (\fBu8\fP * cipher_text, const \fBu8\fP * plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[12])"

.SS "\fBu32\fP crypto_ietf_chacha20_ctr (\fBu8\fP * cipher_text, const \fBu8\fP * plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[12], \fBu32\fP ctr)"

.SS "void crypto_key_exchange (\fBu8\fP shared_key[32], const \fBu8\fP your_secret_key[32], const \fBu8\fP their_public_key[32])"

.PP
Key exchange ///\&. 
.SS "void crypto_lock (\fBu8\fP mac[16], \fBu8\fP * cipher_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP * plain_text, size_t text_size)"

.SS "void crypto_lock_aead (\fBu8\fP mac[16], \fBu8\fP * cipher_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP * ad, size_t ad_size, const \fBu8\fP * plain_text, size_t text_size)"

.SS "void crypto_poly1305 (\fBu8\fP mac[16], const \fBu8\fP * message, size_t message_size, const \fBu8\fP key[32])"

.SS "void crypto_poly1305_final (\fBcrypto_poly1305_ctx\fP * ctx, \fBu8\fP mac[16])"

.SS "void crypto_poly1305_init (\fBcrypto_poly1305_ctx\fP * ctx, const \fBu8\fP key[32])"

.SS "void crypto_poly1305_update (\fBcrypto_poly1305_ctx\fP * ctx, const \fBu8\fP * message, size_t message_size)"

.SS "void crypto_sign (\fBu8\fP signature[64], const \fBu8\fP secret_key[32], const \fBu8\fP public_key[32], const \fBu8\fP * message, size_t message_size)"

.SS "void crypto_sign_final (\fBcrypto_sign_ctx_abstract\fP * ctx, \fBu8\fP signature[64])"

.SS "void crypto_sign_init_first_pass (\fBcrypto_sign_ctx_abstract\fP * ctx, const \fBu8\fP secret_key[32], const \fBu8\fP public_key[32])"

.SS "void crypto_sign_init_first_pass_custom_hash (\fBcrypto_sign_ctx_abstract\fP * ctx, const \fBu8\fP secret_key[32], const \fBu8\fP public_key[32], const \fBcrypto_sign_vtable\fP * hash)"

.SS "void crypto_sign_init_second_pass (\fBcrypto_sign_ctx_abstract\fP * ctx)"

.SS "void crypto_sign_public_key (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"

.SS "void crypto_sign_public_key_custom_hash (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32], const \fBcrypto_sign_vtable\fP * hash)"

.SS "void crypto_sign_update (\fBcrypto_sign_ctx_abstract\fP * ctx, const \fBu8\fP * msg, size_t msg_size)"

.SS "int crypto_unlock (\fBu8\fP * plain_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP mac[16], const \fBu8\fP * cipher_text, size_t text_size)"

.SS "int crypto_unlock_aead (\fBu8\fP * plain_text, const \fBu8\fP key[32], const \fBu8\fP nonce[24], const \fBu8\fP mac[16], const \fBu8\fP * ad, size_t ad_size, const \fBu8\fP * cipher_text, size_t text_size)"

.SS "int crypto_verify16 (const \fBu8\fP a[16], const \fBu8\fP b[16])"

.PP
High level interface ///\&. 
.SS "int crypto_verify32 (const \fBu8\fP a[32], const \fBu8\fP b[32])"

.SS "int crypto_verify64 (const \fBu8\fP a[64], const \fBu8\fP b[64])"

.SS "void crypto_wipe (void * secret, size_t size)"

.SS "void crypto_x25519 (\fBu8\fP raw_shared_secret[32], const \fBu8\fP your_secret_key[32], const \fBu8\fP their_public_key[32])"

.SS "void crypto_x25519_dirty_fast (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"

.SS "void crypto_x25519_dirty_small (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"

.SS "void crypto_x25519_inverse (\fBu8\fP blind_salt[32], const \fBu8\fP private_key[32], const \fBu8\fP curve_point[32])"

.SS "void crypto_x25519_public_key (\fBu8\fP public_key[32], const \fBu8\fP secret_key[32])"

.SS "void crypto_xchacha20 (\fBu8\fP * cipher_text, const \fBu8\fP * plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[24])"

.SS "\fBu64\fP crypto_xchacha20_ctr (\fBu8\fP * cipher_text, const \fBu8\fP * plain_text, size_t text_size, const \fBu8\fP key[32], const \fBu8\fP nonce[24], \fBu64\fP ctr)"

.SH "Variable Documentation"
.PP 
.SS "const \fBcrypto_sign_vtable\fP crypto_blake2b_vtable"
\fBInitial value:\fP
.PP
.nf
= {
    crypto_blake2b,
    blake2b_vtable_init,
    blake2b_vtable_update,
    blake2b_vtable_final,
    sizeof(crypto_sign_ctx),
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Ruba Mazzetto from the source code\&.
