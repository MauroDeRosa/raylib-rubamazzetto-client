.TH "include/external/uthash/utstring.h" 3 "Sun May 8 2022" "Ruba Mazzetto" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/external/uthash/utstring.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdarg\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBUT_string\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBUTSTRING_VERSION\fP   2\&.3\&.0"
.br
.ti -1c
.RI "#define \fBUTSTRING_UNUSED\fP"
.br
.ti -1c
.RI "#define \fButstring_oom\fP()   exit(\-1)"
.br
.ti -1c
.RI "#define \fButstring_reserve\fP(s,  amt)"
.br
.ti -1c
.RI "#define \fButstring_init\fP(s)"
.br
.ti -1c
.RI "#define \fButstring_done\fP(s)"
.br
.ti -1c
.RI "#define \fButstring_free\fP(s)"
.br
.ti -1c
.RI "#define \fButstring_new\fP(s)"
.br
.ti -1c
.RI "#define \fButstring_renew\fP(s)"
.br
.ti -1c
.RI "#define \fButstring_clear\fP(s)"
.br
.ti -1c
.RI "#define \fButstring_bincpy\fP(s,  b,  l)"
.br
.ti -1c
.RI "#define \fButstring_concat\fP(\fBdst\fP,  src)"
.br
.ti -1c
.RI "#define \fButstring_len\fP(s)   ((s)\->i)"
.br
.ti -1c
.RI "#define \fButstring_body\fP(s)   ((s)\->d)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define utstring_bincpy(s, b, l)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  utstring_reserve((s),(l)+1);                             \
  if (l) memcpy(&(s)->d[(s)->i], b, l);                    \
  (s)->i += (l);                                           \
  (s)->d[(s)->i]='\0';                                     \
} while(0)
.fi
.SS "#define utstring_body(s)   ((s)\->d)"

.SS "#define utstring_clear(s)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  (s)->i = 0;                                              \
  (s)->d[0] = '\0';                                        \
} while(0)
.fi
.SS "#define utstring_concat(\fBdst\fP, src)"
\fBValue:\fP
.PP
.nf
do {                                                             \
  utstring_reserve((dst),((src)->i)+1);                          \
  if ((src)->i) memcpy(&(dst)->d[(dst)->i], (src)->d, (src)->i); \
  (dst)->i += (src)->i;                                          \
  (dst)->d[(dst)->i]='\0';                                       \
} while(0)
.fi
.SS "#define utstring_done(s)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  if ((s)->d != NULL) free((s)->d);                        \
  (s)->n = 0;                                              \
} while(0)
.fi
.SS "#define utstring_free(s)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  utstring_done(s);                                        \
  free(s);                                                 \
} while(0)
.fi
.SS "#define utstring_init(s)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  (s)->n = 0; (s)->i = 0; (s)->d = NULL;                   \
  utstring_reserve(s,100);                                 \
  (s)->d[0] = '\0';                                        \
} while(0)
.fi
.SS "#define utstring_len(s)   ((s)\->i)"

.SS "#define utstring_new(s)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  (s) = (UT_string*)malloc(sizeof(UT_string));             \
  if (!(s)) {                                              \
    utstring_oom();                                        \
  }                                                        \
  utstring_init(s);                                        \
} while(0)
.fi
.SS "#define utstring_oom()   exit(\-1)"

.SS "#define utstring_renew(s)"
\fBValue:\fP
.PP
.nf
do {                                                       \
   if (s) {                                                \
     utstring_clear(s);                                    \
   } else {                                                \
     utstring_new(s);                                      \
   }                                                       \
} while(0)
.fi
.SS "#define utstring_reserve(s, amt)"
\fBValue:\fP
.PP
.nf
do {                                                       \
  if (((s)->n - (s)->i) < (size_t)(amt)) {                 \
    char *utstring_tmp = (char*)realloc(                   \
      (s)->d, (s)->n + (amt));                             \
    if (!utstring_tmp) {                                   \
      utstring_oom();                                      \
    }                                                      \
    (s)->d = utstring_tmp;                                 \
    (s)->n += (amt);                                       \
  }                                                        \
} while(0)
.fi
.SS "#define UTSTRING_UNUSED"

.SS "#define UTSTRING_VERSION   2\&.3\&.0"

.SH "Author"
.PP 
Generated automatically by Doxygen for Ruba Mazzetto from the source code\&.
