.TH "include/external/uthash/utarray.h" 3 "Sun May 8 2022" "Ruba Mazzetto" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/external/uthash/utarray.h
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBUT_icd\fP"
.br
.ti -1c
.RI "struct \fBUT_array\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBUTARRAY_VERSION\fP   2\&.3\&.0"
.br
.ti -1c
.RI "#define \fBUTARRAY_UNUSED\fP   = {sizeof(int),NULL,NULL,NULL}"
.br
.ti -1c
.RI "#define \fButarray_oom\fP()   exit(\-1)"
.br
.ti -1c
.RI "#define \fButarray_init\fP(a,  _icd)"
.br
.ti -1c
.RI "#define \fButarray_done\fP(a)"
.br
.ti -1c
.RI "#define \fButarray_new\fP(a,  _icd)"
.br
.ti -1c
.RI "#define \fButarray_free\fP(a)"
.br
.ti -1c
.RI "#define \fButarray_reserve\fP(a,  by)"
.br
.ti -1c
.RI "#define \fButarray_push_back\fP(a,  p)"
.br
.ti -1c
.RI "#define \fButarray_pop_back\fP(a)"
.br
.ti -1c
.RI "#define \fButarray_extend_back\fP(a)"
.br
.ti -1c
.RI "#define \fButarray_len\fP(a)   ((a)\->i)"
.br
.ti -1c
.RI "#define \fButarray_eltptr\fP(a,  j)   (((j) < (a)\->i) ? \fB_utarray_eltptr\fP(a,j) : NULL)"
.br
.ti -1c
.RI "#define \fB_utarray_eltptr\fP(a,  j)   ((void*)((a)\->d + ((a)\->icd\&.sz * (j))))"
.br
.ti -1c
.RI "#define \fButarray_insert\fP(a,  p,  j)"
.br
.ti -1c
.RI "#define \fButarray_inserta\fP(a,  w,  j)"
.br
.ti -1c
.RI "#define \fButarray_resize\fP(\fBdst\fP,  num)"
.br
.ti -1c
.RI "#define \fButarray_concat\fP(\fBdst\fP,  src)"
.br
.ti -1c
.RI "#define \fButarray_erase\fP(a,  pos,  len)"
.br
.ti -1c
.RI "#define \fButarray_renew\fP(a,  u)"
.br
.ti -1c
.RI "#define \fButarray_clear\fP(a)"
.br
.ti -1c
.RI "#define \fButarray_sort\fP(a,  cmp)"
.br
.ti -1c
.RI "#define \fButarray_find\fP(a,  v,  cmp)   bsearch((v),(a)\->d,(a)\->i,(a)\->icd\&.sz,cmp)"
.br
.ti -1c
.RI "#define \fButarray_front\fP(a)   (((a)\->i) ? (\fB_utarray_eltptr\fP(a,0)) : NULL)"
.br
.ti -1c
.RI "#define \fButarray_next\fP(a,  e)   (((e)==NULL) ? \fButarray_front\fP(a) : (((a)\->i != \fButarray_eltidx\fP(a,e)+1) ? \fB_utarray_eltptr\fP(a,\fButarray_eltidx\fP(a,e)+1) : NULL))"
.br
.ti -1c
.RI "#define \fButarray_prev\fP(a,  e)   (((e)==NULL) ? \fButarray_back\fP(a) : ((\fButarray_eltidx\fP(a,e) != 0) ? \fB_utarray_eltptr\fP(a,\fButarray_eltidx\fP(a,e)\-1) : NULL))"
.br
.ti -1c
.RI "#define \fButarray_back\fP(a)   (((a)\->i) ? (\fB_utarray_eltptr\fP(a,(a)\->i\-1)) : NULL)"
.br
.ti -1c
.RI "#define \fButarray_eltidx\fP(a,  e)   (((char*)(e) \- (a)\->d) / (a)\->icd\&.sz)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void() \fBctor_f\fP(void *\fBdst\fP, const void *src)"
.br
.ti -1c
.RI "typedef void() \fBdtor_f\fP(void *elt)"
.br
.ti -1c
.RI "typedef void() \fBinit_f\fP(void *elt)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define _utarray_eltptr(a, j)   ((void*)((a)\->d + ((a)\->icd\&.sz * (j))))"

.SS "#define utarray_back(a)   (((a)\->i) ? (\fB_utarray_eltptr\fP(a,(a)\->i\-1)) : NULL)"

.SS "#define utarray_clear(a)"
\fBValue:\fP
.PP
.nf
  do {                                                 \
  if ((a)->i > 0) {                                                           \
    if ((a)->icd\&.dtor) {                                                      \
      unsigned _ut_i;                                                         \
      for(_ut_i=0; _ut_i < (a)->i; _ut_i++) {                                 \
        (a)->icd\&.dtor(_utarray_eltptr(a, _ut_i));                             \
      }                                                                       \
    }                                                                         \
    (a)->i = 0;                                                               \
  }                                                                           \
} while(0)
.fi
.SS "#define utarray_concat(\fBdst\fP, src)"
\fBValue:\fP
.PP
.nf
  do {                                          \
  utarray_inserta(dst, src, utarray_len(dst));                                \
} while(0)
.fi
.SS "#define utarray_done(a)"
\fBValue:\fP
.PP
.nf
  do {                                                  \
  if ((a)->n) {                                                               \
    if ((a)->icd\&.dtor) {                                                      \
      unsigned _ut_i;                                                         \
      for(_ut_i=0; _ut_i < (a)->i; _ut_i++) {                                 \
        (a)->icd\&.dtor(utarray_eltptr(a,_ut_i));                               \
      }                                                                       \
    }                                                                         \
    free((a)->d);                                                             \
  }                                                                           \
  (a)->n=0;                                                                   \
} while(0)
.fi
.SS "#define utarray_eltidx(a, e)   (((char*)(e) \- (a)\->d) / (a)\->icd\&.sz)"

.SS "#define utarray_eltptr(a, j)   (((j) < (a)\->i) ? \fB_utarray_eltptr\fP(a,j) : NULL)"

.SS "#define utarray_erase(a, pos, len)"
\fBValue:\fP
.PP
.nf
  do {                                         \
  if ((a)->icd\&.dtor) {                                                        \
    unsigned _ut_i;                                                           \
    for (_ut_i = 0; _ut_i < (len); _ut_i++) {                                 \
      (a)->icd\&.dtor(utarray_eltptr(a, (pos) + _ut_i));                        \
    }                                                                         \
  }                                                                           \
  if ((a)->i > ((pos) + (len))) {                                             \
    memmove(_utarray_eltptr(a, pos), _utarray_eltptr(a, (pos) + (len)),       \
            ((a)->i - ((pos) + (len))) * (a)->icd\&.sz);                        \
  }                                                                           \
  (a)->i -= (len);                                                            \
} while(0)
.fi
.SS "#define utarray_extend_back(a)"
\fBValue:\fP
.PP
.nf
  do {                                           \
  utarray_reserve(a,1);                                                       \
  if ((a)->icd\&.init) { (a)->icd\&.init(_utarray_eltptr(a,(a)->i)); }            \
  else { memset(_utarray_eltptr(a,(a)->i),0,(a)->icd\&.sz); }                   \
  (a)->i++;                                                                   \
} while(0)
.fi
.SS "#define utarray_find(a, v, cmp)   bsearch((v),(a)\->d,(a)\->i,(a)\->icd\&.sz,cmp)"

.SS "#define utarray_free(a)"
\fBValue:\fP
.PP
.nf
  do {                                                  \
  utarray_done(a);                                                            \
  free(a);                                                                    \
} while(0)
.fi
.SS "#define utarray_front(a)   (((a)\->i) ? (\fB_utarray_eltptr\fP(a,0)) : NULL)"

.SS "#define utarray_init(a, _icd)"
\fBValue:\fP
.PP
.nf
  do {                                             \
  memset(a,0,sizeof(UT_array));                                               \
  (a)->icd = *(_icd);                                                         \
} while(0)
.fi
.SS "#define utarray_insert(a, p, j)"
\fBValue:\fP
.PP
.nf
  do {                                            \
  if ((j) > (a)->i) utarray_resize(a,j);                                      \
  utarray_reserve(a,1);                                                       \
  if ((j) < (a)->i) {                                                         \
    memmove( _utarray_eltptr(a,(j)+1), _utarray_eltptr(a,j),                  \
             ((a)->i - (j))*((a)->icd\&.sz));                                   \
  }                                                                           \
  if ((a)->icd\&.copy) { (a)->icd\&.copy( _utarray_eltptr(a,j), p); }             \
  else { memcpy(_utarray_eltptr(a,j), p, (a)->icd\&.sz); };                     \
  (a)->i++;                                                                   \
} while(0)
.fi
.SS "#define utarray_inserta(a, w, j)"
\fBValue:\fP
.PP
.nf
  do {                                           \
  if (utarray_len(w) == 0) break;                                             \
  if ((j) > (a)->i) utarray_resize(a,j);                                      \
  utarray_reserve(a,utarray_len(w));                                          \
  if ((j) < (a)->i) {                                                         \
    memmove(_utarray_eltptr(a,(j)+utarray_len(w)),                            \
            _utarray_eltptr(a,j),                                             \
            ((a)->i - (j))*((a)->icd\&.sz));                                    \
  }                                                                           \
  if ((a)->icd\&.copy) {                                                        \
    unsigned _ut_i;                                                           \
    for(_ut_i=0;_ut_i<(w)->i;_ut_i++) {                                       \
      (a)->icd\&.copy(_utarray_eltptr(a, (j) + _ut_i), _utarray_eltptr(w, _ut_i)); \
    }                                                                         \
  } else {                                                                    \
    memcpy(_utarray_eltptr(a,j), _utarray_eltptr(w,0),                        \
           utarray_len(w)*((a)->icd\&.sz));                                     \
  }                                                                           \
  (a)->i += utarray_len(w);                                                   \
} while(0)
.fi
.SS "#define utarray_len(a)   ((a)\->i)"

.SS "#define utarray_new(a, _icd)"
\fBValue:\fP
.PP
.nf
  do {                                              \
  (a) = (UT_array*)malloc(sizeof(UT_array));                                  \
  if ((a) == NULL) {                                                          \
    utarray_oom();                                                            \
  }                                                                           \
  utarray_init(a,_icd);                                                       \
} while(0)
.fi
.SS "#define utarray_next(a, e)   (((e)==NULL) ? \fButarray_front\fP(a) : (((a)\->i != \fButarray_eltidx\fP(a,e)+1) ? \fB_utarray_eltptr\fP(a,\fButarray_eltidx\fP(a,e)+1) : NULL))"

.SS "#define utarray_oom()   exit(\-1)"

.SS "#define utarray_pop_back(a)"
\fBValue:\fP
.PP
.nf
  do {                                              \
  if ((a)->icd\&.dtor) { (a)->icd\&.dtor( _utarray_eltptr(a,--((a)->i))); }       \
  else { (a)->i--; }                                                          \
} while(0)
.fi
.SS "#define utarray_prev(a, e)   (((e)==NULL) ? \fButarray_back\fP(a) : ((\fButarray_eltidx\fP(a,e) != 0) ? \fB_utarray_eltptr\fP(a,\fButarray_eltidx\fP(a,e)\-1) : NULL))"

.SS "#define utarray_push_back(a, p)"
\fBValue:\fP
.PP
.nf
  do {                                           \
  utarray_reserve(a,1);                                                       \
  if ((a)->icd\&.copy) { (a)->icd\&.copy( _utarray_eltptr(a,(a)->i++), p); }      \
  else { memcpy(_utarray_eltptr(a,(a)->i++), p, (a)->icd\&.sz); };              \
} while(0)
.fi
.SS "#define utarray_renew(a, u)"
\fBValue:\fP
.PP
.nf
  do {                                               \
  if (a) utarray_clear(a);                                                    \
  else utarray_new(a, u);                                                     \
} while(0)
.fi
.SS "#define utarray_reserve(a, by)"
\fBValue:\fP
.PP
.nf
  do {                                            \
  if (((a)->i+(by)) > (a)->n) {                                               \
    char *utarray_tmp;                                                        \
    while (((a)->i+(by)) > (a)->n) { (a)->n = ((a)->n ? (2*(a)->n) : 8); }    \
    utarray_tmp=(char*)realloc((a)->d, (a)->n*(a)->icd\&.sz);                   \
    if (utarray_tmp == NULL) {                                                \
      utarray_oom();                                                          \
    }                                                                         \
    (a)->d=utarray_tmp;                                                       \
  }                                                                           \
} while(0)
.fi
.SS "#define utarray_resize(\fBdst\fP, num)"
\fBValue:\fP
.PP
.nf
  do {                                          \
  unsigned _ut_i;                                                             \
  if ((dst)->i > (unsigned)(num)) {                                           \
    if ((dst)->icd\&.dtor) {                                                    \
      for (_ut_i = (num); _ut_i < (dst)->i; ++_ut_i) {                        \
        (dst)->icd\&.dtor(_utarray_eltptr(dst, _ut_i));                         \
      }                                                                       \
    }                                                                         \
  } else if ((dst)->i < (unsigned)(num)) {                                    \
    utarray_reserve(dst, (num) - (dst)->i);                                   \
    if ((dst)->icd\&.init) {                                                    \
      for (_ut_i = (dst)->i; _ut_i < (unsigned)(num); ++_ut_i) {              \
        (dst)->icd\&.init(_utarray_eltptr(dst, _ut_i));                         \
      }                                                                       \
    } else {                                                                  \
      memset(_utarray_eltptr(dst, (dst)->i), 0, (dst)->icd\&.sz*((num) - (dst)->i)); \
    }                                                                         \
  }                                                                           \
  (dst)->i = (num);                                                           \
} while(0)
.fi
.SS "#define utarray_sort(a, cmp)"
\fBValue:\fP
.PP
.nf
  do {                                              \
  qsort((a)->d, (a)->i, (a)->icd\&.sz, cmp);                                    \
} while(0)
.fi
.SS "static const \fBUT_icd\fP ut_ptr_icd UTARRAY_UNUSED   = {sizeof(int),NULL,NULL,NULL}"

.SS "#define UTARRAY_VERSION   2\&.3\&.0"

.SH "Typedef Documentation"
.PP 
.SS "typedef void() ctor_f(void *\fBdst\fP, const void *src)"

.SS "typedef void() dtor_f(void *elt)"

.SS "typedef void() init_f(void *elt)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Ruba Mazzetto from the source code\&.
