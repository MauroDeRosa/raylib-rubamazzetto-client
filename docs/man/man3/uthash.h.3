.TH "include/external/uthash/uthash.h" 3 "Sun May 8 2022" "Ruba Mazzetto" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/external/uthash/uthash.h
.SH SYNOPSIS
.br
.PP
\fC#include <string\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBUT_hash_bucket\fP"
.br
.ti -1c
.RI "struct \fBUT_hash_table\fP"
.br
.ti -1c
.RI "struct \fBUT_hash_handle\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBUTHASH_VERSION\fP   2\&.3\&.0"
.br
.ti -1c
.RI "#define \fBDECLTYPE\fP(x)   (__typeof(x))"
.br
.ti -1c
.RI "#define \fBDECLTYPE_ASSIGN\fP(\fBdst\fP,  src)"
.br
.ti -1c
.RI "#define \fButhash_malloc\fP(sz)   malloc(sz)      /* malloc fcn                      */"
.br
.ti -1c
.RI "#define \fButhash_free\fP(ptr,  sz)   free(ptr)     /* free fcn                        */"
.br
.ti -1c
.RI "#define \fButhash_bzero\fP(a,  n)   memset(a,'\\0',n)"
.br
.ti -1c
.RI "#define \fButhash_strlen\fP(s)   strlen(s)"
.br
.ti -1c
.RI "#define \fBHASH_FUNCTION\fP(keyptr,  keylen,  hashv)   \fBHASH_JEN\fP(keyptr, keylen, hashv)"
.br
.ti -1c
.RI "#define \fBHASH_KEYCMP\fP(a,  b,  n)   memcmp(a,b,n)"
.br
.ti -1c
.RI "#define \fButhash_noexpand_fyi\fP(tbl)   /* can be defined to log noexpand  */"
.br
.ti -1c
.RI "#define \fButhash_expand_fyi\fP(tbl)   /* can be defined to log expands   */"
.br
.ti -1c
.RI "#define \fBHASH_NONFATAL_OOM\fP   0"
.br
.ti -1c
.RI "#define \fButhash_fatal\fP(msg)   exit(\-1)        /* fatal OOM error */"
.br
.ti -1c
.RI "#define \fBHASH_RECORD_OOM\fP(oomed)   \fButhash_fatal\fP('out of memory')"
.br
.ti -1c
.RI "#define \fBIF_HASH_NONFATAL_OOM\fP(x)"
.br
.ti -1c
.RI "#define \fBHASH_INITIAL_NUM_BUCKETS\fP   32U     /* initial number of buckets        */"
.br
.ti -1c
.RI "#define \fBHASH_INITIAL_NUM_BUCKETS_LOG2\fP   5U /* lg2 of initial number of buckets */"
.br
.ti -1c
.RI "#define \fBHASH_BKT_CAPACITY_THRESH\fP   10U     /* expand when bucket count reaches */"
.br
.ti -1c
.RI "#define \fBELMT_FROM_HH\fP(tbl,  hhp)   ((void*)(((char*)(hhp)) \- ((tbl)\->hho)))"
.br
.ti -1c
.RI "#define \fBHH_FROM_ELMT\fP(tbl,  elp)   ((\fBUT_hash_handle\fP*)(void*)(((char*)(elp)) + ((tbl)\->hho)))"
.br
.ti -1c
.RI "#define \fBHASH_ROLLBACK_BKT\fP(hh,  head,  itemptrhh)"
.br
.ti -1c
.RI "#define \fBHASH_VALUE\fP(keyptr,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_FIND_BYHASHVALUE\fP(hh,  head,  keyptr,  keylen,  hashval,  out)"
.br
.ti -1c
.RI "#define \fBHASH_FIND\fP(hh,  head,  keyptr,  keylen,  out)"
.br
.ti -1c
.RI "#define \fBHASH_BLOOM_MAKE\fP(tbl,  oomed)"
.br
.ti -1c
.RI "#define \fBHASH_BLOOM_FREE\fP(tbl)"
.br
.ti -1c
.RI "#define \fBHASH_BLOOM_ADD\fP(tbl,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_BLOOM_TEST\fP(tbl,  hashv)   (1)"
.br
.ti -1c
.RI "#define \fBHASH_BLOOM_BYTELEN\fP   0U"
.br
.ti -1c
.RI "#define \fBHASH_MAKE_TABLE\fP(hh,  head,  oomed)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE_BYHASHVALUE_INORDER\fP(hh,  head,  fieldname,  keylen_in,  hashval,  add,  replaced,  cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE_BYHASHVALUE\fP(hh,  head,  fieldname,  keylen_in,  hashval,  add,  replaced)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE\fP(hh,  head,  fieldname,  keylen_in,  add,  replaced)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE_INORDER\fP(hh,  head,  fieldname,  keylen_in,  add,  replaced,  cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_APPEND_LIST\fP(hh,  head,  add)"
.br
.ti -1c
.RI "#define \fBHASH_AKBI_INNER_LOOP\fP(hh,  head,  add,  cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_TO_TABLE\fP(hh,  head,  keyptr,  keylen_in,  hashval,  add,  oomed)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_KEYPTR_BYHASHVALUE_INORDER\fP(hh,  head,  keyptr,  keylen_in,  hashval,  add,  cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_KEYPTR_INORDER\fP(hh,  head,  keyptr,  keylen_in,  add,  cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_BYHASHVALUE_INORDER\fP(hh,  head,  fieldname,  keylen_in,  hashval,  add,  cmpfcn)     \fBHASH_ADD_KEYPTR_BYHASHVALUE_INORDER\fP(hh, head, &((add)\->fieldname), keylen_in, hashval, add, cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_INORDER\fP(hh,  head,  fieldname,  keylen_in,  add,  cmpfcn)     \fBHASH_ADD_KEYPTR_INORDER\fP(hh, head, &((add)\->fieldname), keylen_in, add, cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_KEYPTR_BYHASHVALUE\fP(hh,  head,  keyptr,  keylen_in,  hashval,  add)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_KEYPTR\fP(hh,  head,  keyptr,  keylen_in,  add)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_BYHASHVALUE\fP(hh,  head,  fieldname,  keylen_in,  hashval,  add)     \fBHASH_ADD_KEYPTR_BYHASHVALUE\fP(hh, head, &((add)\->fieldname), keylen_in, hashval, add)"
.br
.ti -1c
.RI "#define \fBHASH_ADD\fP(hh,  head,  fieldname,  keylen_in,  add)     \fBHASH_ADD_KEYPTR\fP(hh, head, &((add)\->fieldname), keylen_in, add)"
.br
.ti -1c
.RI "#define \fBHASH_TO_BKT\fP(hashv,  num_bkts,  bkt)"
.br
.ti -1c
.RI "#define \fBHASH_DELETE\fP(hh,  head,  delptr)       \fBHASH_DELETE_HH\fP(hh, head, &(delptr)\->hh)"
.br
.ti -1c
.RI "#define \fBHASH_DELETE_HH\fP(hh,  head,  delptrhh)"
.br
.ti -1c
.RI "#define \fBHASH_FIND_STR\fP(head,  findstr,  out)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_STR\fP(head,  strfield,  add)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE_STR\fP(head,  strfield,  add,  replaced)"
.br
.ti -1c
.RI "#define \fBHASH_FIND_INT\fP(head,  findint,  out)       \fBHASH_FIND\fP(hh,head,findint,sizeof(int),out)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_INT\fP(head,  intfield,  add)       \fBHASH_ADD\fP(hh,head,intfield,sizeof(int),add)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE_INT\fP(head,  intfield,  add,  replaced)       \fBHASH_REPLACE\fP(hh,head,intfield,sizeof(int),add,replaced)"
.br
.ti -1c
.RI "#define \fBHASH_FIND_PTR\fP(head,  findptr,  out)       \fBHASH_FIND\fP(hh,head,findptr,sizeof(void *),out)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_PTR\fP(head,  ptrfield,  add)       \fBHASH_ADD\fP(hh,head,ptrfield,sizeof(void *),add)"
.br
.ti -1c
.RI "#define \fBHASH_REPLACE_PTR\fP(head,  ptrfield,  add,  replaced)       \fBHASH_REPLACE\fP(hh,head,ptrfield,sizeof(void *),add,replaced)"
.br
.ti -1c
.RI "#define \fBHASH_DEL\fP(head,  delptr)       \fBHASH_DELETE\fP(hh,head,delptr)"
.br
.ti -1c
.RI "#define \fBHASH_FSCK\fP(hh,  head,  where)"
.br
.ti -1c
.RI "#define \fBHASH_EMIT_KEY\fP(hh,  head,  keyptr,  fieldlen)"
.br
.ti -1c
.RI "#define \fBHASH_BER\fP(key,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_SAX\fP(key,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_FNV\fP(key,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_OAT\fP(key,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_JEN_MIX\fP(a,  b,  c)"
.br
.ti -1c
.RI "#define \fBHASH_JEN\fP(key,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBget16bits\fP(d)"
.br
.ti -1c
.RI "#define \fBHASH_SFH\fP(key,  keylen,  hashv)"
.br
.ti -1c
.RI "#define \fBHASH_FIND_IN_BKT\fP(tbl,  hh,  head,  keyptr,  keylen_in,  hashval,  out)"
.br
.ti -1c
.RI "#define \fBHASH_ADD_TO_BKT\fP(head,  hh,  addhh,  oomed)"
.br
.ti -1c
.RI "#define \fBHASH_DEL_IN_BKT\fP(head,  delhh)"
.br
.ti -1c
.RI "#define \fBHASH_EXPAND_BUCKETS\fP(hh,  tbl,  oomed)"
.br
.ti -1c
.RI "#define \fBHASH_SORT\fP(head,  cmpfcn)   \fBHASH_SRT\fP(hh,head,cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_SRT\fP(hh,  head,  cmpfcn)"
.br
.ti -1c
.RI "#define \fBHASH_SELECT\fP(hh_dst,  \fBdst\fP,  hh_src,  src,  cond)"
.br
.ti -1c
.RI "#define \fBHASH_CLEAR\fP(hh,  head)"
.br
.ti -1c
.RI "#define \fBHASH_OVERHEAD\fP(hh,  head)"
.br
.ti -1c
.RI "#define \fBHASH_ITER\fP(hh,  head,  el,  tmp)"
.br
.ti -1c
.RI "#define \fBHASH_COUNT\fP(head)   \fBHASH_CNT\fP(hh,head)"
.br
.ti -1c
.RI "#define \fBHASH_CNT\fP(hh,  head)   ((head != NULL)?((head)\->hh\&.tbl\->num_items):0U)"
.br
.ti -1c
.RI "#define \fBHASH_SIGNATURE\fP   0xa0111fe1u"
.br
.ti -1c
.RI "#define \fBHASH_BLOOM_SIGNATURE\fP   0xb12220f2u"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBUT_hash_bucket\fP \fBUT_hash_bucket\fP"
.br
.ti -1c
.RI "typedef struct \fBUT_hash_table\fP \fBUT_hash_table\fP"
.br
.ti -1c
.RI "typedef struct \fBUT_hash_handle\fP \fBUT_hash_handle\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define DECLTYPE(x)   (__typeof(x))"

.SS "#define DECLTYPE_ASSIGN(\fBdst\fP, src)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (dst) = DECLTYPE(dst)(src);                                                    \
} while (0)
.fi
.SS "#define ELMT_FROM_HH(tbl, hhp)   ((void*)(((char*)(hhp)) \- ((tbl)\->hho)))"

.SS "#define get16bits(d)"
\fBValue:\fP
.PP
.nf
                       ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)             \
                       +(uint32_t)(((const uint8_t *)(d))[0]) )
.fi
.SS "#define HASH_ADD(hh, head, fieldname, keylen_in, add)     \fBHASH_ADD_KEYPTR\fP(hh, head, &((add)\->fieldname), keylen_in, add)"

.SS "#define HASH_ADD_BYHASHVALUE(hh, head, fieldname, keylen_in, hashval, add)     \fBHASH_ADD_KEYPTR_BYHASHVALUE\fP(hh, head, &((add)\->fieldname), keylen_in, hashval, add)"

.SS "#define HASH_ADD_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, hashval, add, cmpfcn)     \fBHASH_ADD_KEYPTR_BYHASHVALUE_INORDER\fP(hh, head, &((add)\->fieldname), keylen_in, hashval, add, cmpfcn)"

.SS "#define HASH_ADD_INORDER(hh, head, fieldname, keylen_in, add, cmpfcn)     \fBHASH_ADD_KEYPTR_INORDER\fP(hh, head, &((add)\->fieldname), keylen_in, add, cmpfcn)"

.SS "#define HASH_ADD_INT(head, intfield, add)       \fBHASH_ADD\fP(hh,head,intfield,sizeof(int),add)"

.SS "#define HASH_ADD_KEYPTR(hh, head, keyptr, keylen_in, add)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _ha_hashv;                                                            \
  HASH_VALUE(keyptr, keylen_in, _ha_hashv);                                      \
  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, _ha_hashv, add);      \
} while (0)
.fi
.SS "#define HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, hashval, add)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  IF_HASH_NONFATAL_OOM( int _ha_oomed = 0; )                                     \
  (add)->hh\&.hashv = (hashval);                                                   \
  (add)->hh\&.key = (const void*) (keyptr);                                        \
  (add)->hh\&.keylen = (unsigned) (keylen_in);                                     \
  if (!(head)) {                                                                 \
    (add)->hh\&.next = NULL;                                                       \
    (add)->hh\&.prev = NULL;                                                       \
    HASH_MAKE_TABLE(hh, add, _ha_oomed);                                         \
    IF_HASH_NONFATAL_OOM( if (!_ha_oomed) { )                                    \
      (head) = (add);                                                            \
    IF_HASH_NONFATAL_OOM( } )                                                    \
  } else {                                                                       \
    (add)->hh\&.tbl = (head)->hh\&.tbl;                                              \
    HASH_APPEND_LIST(hh, head, add);                                             \
  }                                                                              \
  HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, _ha_oomed);       \
  HASH_FSCK(hh, head, "HASH_ADD_KEYPTR_BYHASHVALUE");                            \
} while (0)
.fi
.SS "#define HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, hashval, add, cmpfcn)"

.SS "#define HASH_ADD_KEYPTR_INORDER(hh, head, keyptr, keylen_in, add, cmpfcn)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _hs_hashv;                                                            \
  HASH_VALUE(keyptr, keylen_in, _hs_hashv);                                      \
  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, _hs_hashv, add, cmpfcn); \
} while (0)
.fi
.SS "#define HASH_ADD_PTR(head, ptrfield, add)       \fBHASH_ADD\fP(hh,head,ptrfield,sizeof(void *),add)"

.SS "#define HASH_ADD_STR(head, strfield, add)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
    unsigned _uthash_hastr_keylen = (unsigned)uthash_strlen((add)->strfield);    \
    HASH_ADD(hh, head, strfield[0], _uthash_hastr_keylen, add);                  \
} while (0)
.fi
.SS "#define HASH_ADD_TO_BKT(head, hh, addhh, oomed)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  UT_hash_bucket *_ha_head = &(head);                                            \
  _ha_head->count++;                                                             \
  (addhh)->hh_next = _ha_head->hh_head;                                          \
  (addhh)->hh_prev = NULL;                                                       \
  if (_ha_head->hh_head != NULL) {                                               \
    _ha_head->hh_head->hh_prev = (addhh);                                        \
  }                                                                              \
  _ha_head->hh_head = (addhh);                                                   \
  if ((_ha_head->count >= ((_ha_head->expand_mult + 1U) * HASH_BKT_CAPACITY_THRESH)) \
      && !(addhh)->tbl->noexpand) {                                              \
    HASH_EXPAND_BUCKETS(addhh,(addhh)->tbl, oomed);                              \
    IF_HASH_NONFATAL_OOM(                                                        \
      if (oomed) {                                                               \
        HASH_DEL_IN_BKT(head,addhh);                                             \
      }                                                                          \
    )                                                                            \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, oomed)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _ha_bkt;                                                              \
  (head)->hh\&.tbl->num_items++;                                                   \
  HASH_TO_BKT(hashval, (head)->hh\&.tbl->num_buckets, _ha_bkt);                    \
  HASH_ADD_TO_BKT((head)->hh\&.tbl->buckets[_ha_bkt], hh, &(add)->hh, oomed);      \
  HASH_BLOOM_ADD((head)->hh\&.tbl, hashval);                                       \
  HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                    \
} while (0)
.fi
.SS "#define HASH_AKBI_INNER_LOOP(hh, head, add, cmpfcn)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  do {                                                                           \
    if (cmpfcn(DECLTYPE(head)(_hs_iter), add) > 0) {                             \
      break;                                                                     \
    }                                                                            \
  } while ((_hs_iter = HH_FROM_ELMT((head)->hh\&.tbl, _hs_iter)->next));           \
} while (0)
.fi
.SS "#define HASH_APPEND_LIST(hh, head, add)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (add)->hh\&.next = NULL;                                                         \
  (add)->hh\&.prev = ELMT_FROM_HH((head)->hh\&.tbl, (head)->hh\&.tbl->tail);           \
  (head)->hh\&.tbl->tail->next = (add);                                            \
  (head)->hh\&.tbl->tail = &((add)->hh);                                           \
} while (0)
.fi
.SS "#define HASH_BER(key, keylen, hashv)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _hb_keylen = (unsigned)keylen;                                        \
  const unsigned char *_hb_key = (const unsigned char*)(key);                    \
  (hashv) = 0;                                                                   \
  while (_hb_keylen-- != 0U) {                                                   \
    (hashv) = (((hashv) << 5) + (hashv)) + *_hb_key++;                           \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_BKT_CAPACITY_THRESH   10U     /* expand when bucket count reaches */"

.SS "#define HASH_BLOOM_ADD(tbl, hashv)"

.SS "#define HASH_BLOOM_BYTELEN   0U"

.SS "#define HASH_BLOOM_FREE(tbl)"

.SS "#define HASH_BLOOM_MAKE(tbl, oomed)"

.SS "#define HASH_BLOOM_SIGNATURE   0xb12220f2u"

.SS "#define HASH_BLOOM_TEST(tbl, hashv)   (1)"

.SS "#define HASH_CLEAR(hh, head)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  if ((head) != NULL) {                                                          \
    HASH_BLOOM_FREE((head)->hh\&.tbl);                                             \
    uthash_free((head)->hh\&.tbl->buckets,                                         \
                (head)->hh\&.tbl->num_buckets*sizeof(struct UT_hash_bucket));      \
    uthash_free((head)->hh\&.tbl, sizeof(UT_hash_table));                          \
    (head) = NULL;                                                               \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_CNT(hh, head)   ((head != NULL)?((head)\->hh\&.tbl\->num_items):0U)"

.SS "#define HASH_COUNT(head)   \fBHASH_CNT\fP(hh,head)"

.SS "#define HASH_DEL(head, delptr)       \fBHASH_DELETE\fP(hh,head,delptr)"

.SS "#define HASH_DEL_IN_BKT(head, delhh)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  UT_hash_bucket *_hd_head = &(head);                                            \
  _hd_head->count--;                                                             \
  if (_hd_head->hh_head == (delhh)) {                                            \
    _hd_head->hh_head = (delhh)->hh_next;                                        \
  }                                                                              \
  if ((delhh)->hh_prev) {                                                        \
    (delhh)->hh_prev->hh_next = (delhh)->hh_next;                                \
  }                                                                              \
  if ((delhh)->hh_next) {                                                        \
    (delhh)->hh_next->hh_prev = (delhh)->hh_prev;                                \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_DELETE(hh, head, delptr)       \fBHASH_DELETE_HH\fP(hh, head, &(delptr)\->hh)"

.SS "#define HASH_DELETE_HH(hh, head, delptrhh)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  struct UT_hash_handle *_hd_hh_del = (delptrhh);                                \
  if ((_hd_hh_del->prev == NULL) && (_hd_hh_del->next == NULL)) {                \
    HASH_BLOOM_FREE((head)->hh\&.tbl);                                             \
    uthash_free((head)->hh\&.tbl->buckets,                                         \
                (head)->hh\&.tbl->num_buckets * sizeof(struct UT_hash_bucket));    \
    uthash_free((head)->hh\&.tbl, sizeof(UT_hash_table));                          \
    (head) = NULL;                                                               \
  } else {                                                                       \
    unsigned _hd_bkt;                                                            \
    if (_hd_hh_del == (head)->hh\&.tbl->tail) {                                    \
      (head)->hh\&.tbl->tail = HH_FROM_ELMT((head)->hh\&.tbl, _hd_hh_del->prev);     \
    }                                                                            \
    if (_hd_hh_del->prev != NULL) {                                              \
      HH_FROM_ELMT((head)->hh\&.tbl, _hd_hh_del->prev)->next = _hd_hh_del->next;   \
    } else {                                                                     \
      DECLTYPE_ASSIGN(head, _hd_hh_del->next);                                   \
    }                                                                            \
    if (_hd_hh_del->next != NULL) {                                              \
      HH_FROM_ELMT((head)->hh\&.tbl, _hd_hh_del->next)->prev = _hd_hh_del->prev;   \
    }                                                                            \
    HASH_TO_BKT(_hd_hh_del->hashv, (head)->hh\&.tbl->num_buckets, _hd_bkt);        \
    HASH_DEL_IN_BKT((head)->hh\&.tbl->buckets[_hd_bkt], _hd_hh_del);               \
    (head)->hh\&.tbl->num_items--;                                                 \
  }                                                                              \
  HASH_FSCK(hh, head, "HASH_DELETE_HH");                                         \
} while (0)
.fi
.SS "#define HASH_EMIT_KEY(hh, head, keyptr, fieldlen)"

.SS "#define HASH_EXPAND_BUCKETS(hh, tbl, oomed)"

.SS "#define HASH_FIND(hh, head, keyptr, keylen, out)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (out) = NULL;                                                                  \
  if (head) {                                                                    \
    unsigned _hf_hashv;                                                          \
    HASH_VALUE(keyptr, keylen, _hf_hashv);                                       \
    HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, _hf_hashv, out);             \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, hashval, out)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (out) = NULL;                                                                  \
  if (head) {                                                                    \
    unsigned _hf_bkt;                                                            \
    HASH_TO_BKT(hashval, (head)->hh\&.tbl->num_buckets, _hf_bkt);                  \
    if (HASH_BLOOM_TEST((head)->hh\&.tbl, hashval) != 0) {                         \
      HASH_FIND_IN_BKT((head)->hh\&.tbl, hh, (head)->hh\&.tbl->buckets[ _hf_bkt ], keyptr, keylen, hashval, out); \
    }                                                                            \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_FIND_IN_BKT(tbl, hh, head, keyptr, keylen_in, hashval, out)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  if ((head)\&.hh_head != NULL) {                                                  \
    DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (head)\&.hh_head));                     \
  } else {                                                                       \
    (out) = NULL;                                                                \
  }                                                                              \
  while ((out) != NULL) {                                                        \
    if ((out)->hh\&.hashv == (hashval) && (out)->hh\&.keylen == (keylen_in)) {       \
      if (HASH_KEYCMP((out)->hh\&.key, keyptr, keylen_in) == 0) {                  \
        break;                                                                   \
      }                                                                          \
    }                                                                            \
    if ((out)->hh\&.hh_next != NULL) {                                             \
      DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (out)->hh\&.hh_next));                \
    } else {                                                                     \
      (out) = NULL;                                                              \
    }                                                                            \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_FIND_INT(head, findint, out)       \fBHASH_FIND\fP(hh,head,findint,sizeof(int),out)"

.SS "#define HASH_FIND_PTR(head, findptr, out)       \fBHASH_FIND\fP(hh,head,findptr,sizeof(void *),out)"

.SS "#define HASH_FIND_STR(head, findstr, out)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
    unsigned _uthash_hfstr_keylen = (unsigned)uthash_strlen(findstr);            \
    HASH_FIND(hh, head, findstr, _uthash_hfstr_keylen, out);                     \
} while (0)
.fi
.SS "#define HASH_FNV(key, keylen, hashv)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _fn_i;                                                                \
  const unsigned char *_hf_key = (const unsigned char*)(key);                    \
  (hashv) = 2166136261U;                                                         \
  for (_fn_i=0; _fn_i < keylen; _fn_i++) {                                       \
    hashv = hashv ^ _hf_key[_fn_i];                                              \
    hashv = hashv * 16777619U;                                                   \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_FSCK(hh, head, where)"

.SS "#define HASH_FUNCTION(keyptr, keylen, hashv)   \fBHASH_JEN\fP(keyptr, keylen, hashv)"

.SS "#define HASH_INITIAL_NUM_BUCKETS   32U     /* initial number of buckets        */"

.SS "#define HASH_INITIAL_NUM_BUCKETS_LOG2   5U /* lg2 of initial number of buckets */"

.SS "#define HASH_ITER(hh, head, el, tmp)"
\fBValue:\fP
.PP
.nf
for(((el)=(head)), ((tmp)=DECLTYPE(el)((head!=NULL)?(head)->hh\&.next:NULL));      \
  (el) != NULL; ((el)=(tmp)), ((tmp)=DECLTYPE(el)((tmp!=NULL)?(tmp)->hh\&.next:NULL)))
.fi
.SS "#define HASH_JEN(key, keylen, hashv)"

.SS "#define HASH_JEN_MIX(a, b, c)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  a -= b; a -= c; a ^= ( c >> 13 );                                              \
  b -= c; b -= a; b ^= ( a << 8 );                                               \
  c -= a; c -= b; c ^= ( b >> 13 );                                              \
  a -= b; a -= c; a ^= ( c >> 12 );                                              \
  b -= c; b -= a; b ^= ( a << 16 );                                              \
  c -= a; c -= b; c ^= ( b >> 5 );                                               \
  a -= b; a -= c; a ^= ( c >> 3 );                                               \
  b -= c; b -= a; b ^= ( a << 10 );                                              \
  c -= a; c -= b; c ^= ( b >> 15 );                                              \
} while (0)
.fi
.SS "#define HASH_KEYCMP(a, b, n)   memcmp(a,b,n)"

.SS "#define HASH_MAKE_TABLE(hh, head, oomed)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (head)->hh\&.tbl = (UT_hash_table*)uthash_malloc(sizeof(UT_hash_table));         \
  if (!(head)->hh\&.tbl) {                                                         \
    HASH_RECORD_OOM(oomed);                                                      \
  } else {                                                                       \
    uthash_bzero((head)->hh\&.tbl, sizeof(UT_hash_table));                         \
    (head)->hh\&.tbl->tail = &((head)->hh);                                        \
    (head)->hh\&.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                      \
    (head)->hh\&.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;            \
    (head)->hh\&.tbl->hho = (char*)(&(head)->hh) - (char*)(head);                  \
    (head)->hh\&.tbl->buckets = (UT_hash_bucket*)uthash_malloc(                    \
        HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket));               \
    (head)->hh\&.tbl->signature = HASH_SIGNATURE;                                  \
    if (!(head)->hh\&.tbl->buckets) {                                              \
      HASH_RECORD_OOM(oomed);                                                    \
      uthash_free((head)->hh\&.tbl, sizeof(UT_hash_table));                        \
    } else {                                                                     \
      uthash_bzero((head)->hh\&.tbl->buckets,                                      \
          HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket));             \
      HASH_BLOOM_MAKE((head)->hh\&.tbl, oomed);                                    \
      IF_HASH_NONFATAL_OOM(                                                      \
        if (oomed) {                                                             \
          uthash_free((head)->hh\&.tbl->buckets,                                   \
              HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));           \
          uthash_free((head)->hh\&.tbl, sizeof(UT_hash_table));                    \
        }                                                                        \
      )                                                                          \
    }                                                                            \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_NONFATAL_OOM   0"

.SS "#define HASH_OAT(key, keylen, hashv)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _ho_i;                                                                \
  const unsigned char *_ho_key=(const unsigned char*)(key);                      \
  hashv = 0;                                                                     \
  for(_ho_i=0; _ho_i < keylen; _ho_i++) {                                        \
      hashv += _ho_key[_ho_i];                                                   \
      hashv += (hashv << 10);                                                    \
      hashv ^= (hashv >> 6);                                                     \
  }                                                                              \
  hashv += (hashv << 3);                                                         \
  hashv ^= (hashv >> 11);                                                        \
  hashv += (hashv << 15);                                                        \
} while (0)
.fi
.SS "#define HASH_OVERHEAD(hh, head)"
\fBValue:\fP
.PP
.nf
 (((head) != NULL) ? (                                                           \
 (size_t)(((head)->hh\&.tbl->num_items   * sizeof(UT_hash_handle))   +             \
          ((head)->hh\&.tbl->num_buckets * sizeof(UT_hash_bucket))   +             \
           sizeof(UT_hash_table)                                   +             \
           (HASH_BLOOM_BYTELEN))) : 0U)
.fi
.SS "#define HASH_RECORD_OOM(oomed)   \fButhash_fatal\fP('out of memory')"

.SS "#define HASH_REPLACE(hh, head, fieldname, keylen_in, add, replaced)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _hr_hashv;                                                            \
  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \
  HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced); \
} while (0)
.fi
.SS "#define HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, hashval, add, replaced)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (replaced) = NULL;                                                             \
  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \
  if (replaced) {                                                                \
    HASH_DELETE(hh, head, replaced);                                             \
  }                                                                              \
  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add); \
} while (0)
.fi
.SS "#define HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, hashval, add, replaced, cmpfcn)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  (replaced) = NULL;                                                             \
  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \
  if (replaced) {                                                                \
    HASH_DELETE(hh, head, replaced);                                             \
  }                                                                              \
  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn); \
} while (0)
.fi
.SS "#define HASH_REPLACE_INORDER(hh, head, fieldname, keylen_in, add, replaced, cmpfcn)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _hr_hashv;                                                            \
  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \
  HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced, cmpfcn); \
} while (0)
.fi
.SS "#define HASH_REPLACE_INT(head, intfield, add, replaced)       \fBHASH_REPLACE\fP(hh,head,intfield,sizeof(int),add,replaced)"

.SS "#define HASH_REPLACE_PTR(head, ptrfield, add, replaced)       \fBHASH_REPLACE\fP(hh,head,ptrfield,sizeof(void *),add,replaced)"

.SS "#define HASH_REPLACE_STR(head, strfield, add, replaced)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
    unsigned _uthash_hrstr_keylen = (unsigned)uthash_strlen((add)->strfield);    \
    HASH_REPLACE(hh, head, strfield[0], _uthash_hrstr_keylen, add, replaced);    \
} while (0)
.fi
.SS "#define HASH_ROLLBACK_BKT(hh, head, itemptrhh)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  struct UT_hash_handle *_hd_hh_item = (itemptrhh);                              \
  unsigned _hd_bkt;                                                              \
  HASH_TO_BKT(_hd_hh_item->hashv, (head)->hh\&.tbl->num_buckets, _hd_bkt);         \
  (head)->hh\&.tbl->buckets[_hd_bkt]\&.count++;                                      \
  _hd_hh_item->hh_next = NULL;                                                   \
  _hd_hh_item->hh_prev = NULL;                                                   \
} while (0)
.fi
.SS "#define HASH_SAX(key, keylen, hashv)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  unsigned _sx_i;                                                                \
  const unsigned char *_hs_key = (const unsigned char*)(key);                    \
  hashv = 0;                                                                     \
  for (_sx_i=0; _sx_i < keylen; _sx_i++) {                                       \
    hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                       \
  }                                                                              \
} while (0)
.fi
.SS "#define HASH_SELECT(hh_dst, \fBdst\fP, hh_src, src, cond)"

.SS "#define HASH_SFH(key, keylen, hashv)"

.SS "#define HASH_SIGNATURE   0xa0111fe1u"

.SS "#define HASH_SORT(head, cmpfcn)   \fBHASH_SRT\fP(hh,head,cmpfcn)"

.SS "#define HASH_SRT(hh, head, cmpfcn)"

.SS "#define HASH_TO_BKT(hashv, num_bkts, bkt)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  bkt = ((hashv) & ((num_bkts) - 1U));                                           \
} while (0)
.fi
.SS "#define HASH_VALUE(keyptr, keylen, hashv)"
\fBValue:\fP
.PP
.nf
do {                                                                             \
  HASH_FUNCTION(keyptr, keylen, hashv);                                          \
} while (0)
.fi
.SS "#define HH_FROM_ELMT(tbl, elp)   ((\fBUT_hash_handle\fP*)(void*)(((char*)(elp)) + ((tbl)\->hho)))"

.SS "#define IF_HASH_NONFATAL_OOM(x)"

.SS "#define uthash_bzero(a, n)   memset(a,'\\0',n)"

.SS "#define uthash_expand_fyi(tbl)   /* can be defined to log expands   */"

.SS "#define uthash_fatal(msg)   exit(\-1)        /* fatal OOM error */"

.SS "#define uthash_free(ptr, sz)   free(ptr)     /* free fcn                        */"

.SS "#define uthash_malloc(sz)   malloc(sz)      /* malloc fcn                      */"

.SS "#define uthash_noexpand_fyi(tbl)   /* can be defined to log noexpand  */"

.SS "#define uthash_strlen(s)   strlen(s)"

.SS "#define UTHASH_VERSION   2\&.3\&.0"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBUT_hash_bucket\fP \fBUT_hash_bucket\fP"

.SS "typedef struct \fBUT_hash_handle\fP \fBUT_hash_handle\fP"

.SS "typedef struct \fBUT_hash_table\fP \fBUT_hash_table\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for Ruba Mazzetto from the source code\&.
